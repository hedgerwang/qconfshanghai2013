<h1>React</h1>

===

<h2>關於</h2>
<ul>
  <li defer>Hedger Wang</li>
  <li defer>前端工程師</li>
  <li defer>2011 - Facebook</li>
  <li defer>2008 - Google</li>
  <li defer>2004 - Yahoo</li>
</ul>

<!-- 
Self introduction.
-->

===

<h2>Component</h2>

<!-- 
Start with talking about the component on the web.
-->

===

<h2>從HTML Markup 到 Component Markup</h2>
<xmp defer>
<div class="DateRange">
  開始 : <input  
          type="text" 
          name="date-start" 
          value="2013/1/1" />
  結束: <input 
          type="text" 
          name="date-end" 
          value="2013/1/31" />
</div>  
</xmp>  

<xmp defer>
<DateRange 
  from="2013/1/1" 
  to="2013/1/31" 
  name="date" 
/>  
</xmp>  

<!-- 
Show some pseudo HTML markups that demostrates the difference between the HTML 
markup and the Component markup. Apparently, the component markup looks much 
simpler and clear.
-->

===

<h2>Web Component</h2>
<ul>
<li defer>W3C Draft</li>  
<li defer>Google Polymer</li>
<li defer>Mozilla X-Tag</li>
<li defer><del>MicroSoft HTML Component</del></li>
</ul> 


<!--
Give background knowledge about the recent status of web component.
--> 
===

<h2>React Component</h2>

<ul>
  <li defer>UI的表現邏輯層 (View)</li>
  <li defer>UI構造的基本單位</li>
  <li defer>UI工具箱</li>
</ul>

<!--
Then move onto the React Component part.
React is a JavaScript library for creating user interfaces by Facebook and
Instagram. Many people choose to think of React as the V in MVC.
-->  

===

<xmp>
<div class="Hello">
  Hello, Hedger
</div>
</xmp>

<!--
Show a basic example of a "Hello" component with HTML Markup.
-->

===

<xmp>
<Hello name="Hedger" />
</xmp>

<!--
Show a basic example of a "Hello" component with (conceptual) Component Markup.
-->

<xmp defer>
React.renderComponent(
  Hello({name: 'Hedger'}),  
  document.body
);
</xmp>

<!--
Present the pseudo JavaScript code that renders the component with the React
library.
-->

<xmp defer>
var Hello = React.createClass({
  render: function() {
    return React.DOM.div(
      {className: 'Hello'},
      'Hello ' + this.props.name
    );
  }
});
</xmp>

<!--
Present the pseudo JavaScript code that defines the component with the React
library.
-->

===

<h2>JSX語法</h2>

<!--
Introduce JSX.  
JSX is a JavaScript XML syntax transform recommended for use with React.
-->

===

<xmp defer>
<Hello name="Hedger" />
</xmp>

<xmp defer>
React.renderComponent(
  <Hello name="Hedger" />,  
  document.body
);
</xmp>

<xmp defer>
var Hello = React.createClass({
  render: function() {
    return (
      <div className="Hello">
        Hello {this.props.name}
      </div>
    );
  }
});
</xmp>

<!--
Show pseudo code of using JSX for the Hello component. 
-->

===

<h2>使用JSX</h2>

<!--
We recommend using JSX for many reasons:  
* It's easier to visualize the structure of the DOM.
* Designers are more comfortable making changes.
* It's familiar for those who have used MXML or XAML.
-->  
===

<h2>聲明式代碼</h2>

<xmp defer>
var table = document.createElement('table');
var tr = document.createElement('tr');
var td = document.createElement('td');
var text = document.createTextNode('some data');
td.appendChild(text);
td = document.createElement('td');
text = document.createTextNode('some more data');
td.appendChild(text);
tr.appendChild(td);
table.appendChild(tr);
</xmp>

<xmp defer>
<table>
  <tr>
    <td>some data</td>
    <td>some data</td>
  </tr>
</table>
</xmp>

<!--
* It's easier to visualize the structure of the DOM.
* Designers are more comfortable making changes.
* It's familiar for those who have used MXML or XAML.
--> 

===

<h2>免除XSS攻擊</h2>

<xmp defer>
var name = '<script>alert("XSS");</script>';
var div = <div>{name}</div>;
</xmp>

<xmp defer>
<div>&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;</div>
</xmp>

<!--
React is safe. We are not generating HTML strings so XSS protection is the 
default.
-->

===

<h2>JavaScript語法</h2>

<xmp defer>
var items = ['apple', 'banana', 'cranberry'];

var renderItem = function(item) {
  return <li>{item}</li>;
};

var list = (
  <ul className={items.length ? '' : 'empty'}>
    {items.map(renderItem)}
  </ul>
);
</xmp>

<!--
This is not another language that you need to learn. You can take advantage of
the full features of JavaScript.  
-->

===

<h2>Composite Component</h2>

<xmp>
var UserCard = React.createClass({
  render: function() {
     return (
       <div>
         <UserPhoto userID={this.props.id} />
         <UserProfile userID={this.props.id} />
       </div>
     );
  }
});
</xmp>

<!--
Give anothe example of how to build a composite (complex) component with 
other components and JSX.
-->

===

<h2>Rendering</h2>

<ul>
  <li defer>在過去，頁面內容是直接從服務端輸出的</li>
  <li defer>只要重新整理頁面，就可以取得更新的UI</li>
  <li defer>對用戶端瀏覽器來說，只要負責顯示就好</li>
</ul>


===

<p>讓事情變得更簡單</p>
<p>讓UI能夠反應數據的狀態</p>

<!--
Web was designed specifically for the mainframe server in the 1970s. The 
server renders the whole screen contents and then sends over the network to 
the terminal.

Whenever the clinet does something that needs to update the screen, the server 
will re-render the entire screen. In the past many years, this model works 
quite well on the Web. This simple approach achieves the web frameworks such 
as LAMP, Rails, Django, PHP and other technologies.
-->

===

<h2>Reactive Rendering</h2>

<ul>
  <li defer>
  一開始React會根據初始數據render整個Component
  </li>

  <li defer>
  當數據更新時，React會重新render整個Component
  </li>

  <li defer>
  不需要複雜的"Data Binding"
  </li>
</ul>

<!--
Explain how reactive rendering works:
When the data changes, React conceptually hits the "refresh" button, and knows 
to only update the changed parts.  
-->

===

<xmp>
var Counter = React.createClass({
  render: function() {
    return <div>count : {this.props.count}</div>;
  }
});
</xmp>
<xmp>
var ii = 0;  
setInterval(function() {
  React.renderComponent(
    <Counter count={ii++} />,
    document.getElementById('renderTarget')
  );
}, 1000);
</xmp>


<!--
Show pseudo codes for "Reactive Rendering".
-->  

===

<h2>當數據更新時...</h2>

<xmp defer>
<div id="page">
  <table>
    <tr>
      <td>1 + 1 = </td>
      <td id="result">?</td>
    </tr>
  </table>
</div>
</xmp>

<!--
Elaborate the case of how markup should be updated when the data changes.
-->  

===
<h3>經由DOM操作來Rendering...</h3>
<xmp>
page.innerHTML = (
  '<table>' +
  '  <tr>' +
  '    <td>1 + 1 = </td>' +
  '    <td id="result">2</td>' +
  '  </tr>' +
  '</table>'
);
</xmp>

<ul>
<li defer>成本高</li>
<li defer>效益低</li>
<li defer>UI狀態容易丟失</li>
</ul>

<!--
This examples show that using `innerHTML` is a bad idea of update markups 
because: 
* It trigger excessive DOM parsing and reflow process.
* It may mess up form fields and scroll position.
-->

===

<h3>減少DOM層級的操作</h3>
<xmp>
result.innerHTML = '2';
</xmp>

<!-- 
Instead, React only touches the minimun sets of DOM nodes to update the markup.
-->

===

<h2>Virtual DOM Tree</h2>

<ul>
<li defer>用JavaScript打造的虛擬DOM Tree</li>
<li defer>避免Reflow</li>
<li defer>支持Events管理</li>
</ul>

<!--
Introduce the concept of the Virtual DOM in React. 
-->  
===

<h2>當數據改變時....</h2>

<ul>
<li defer>產生一個新的Virtual DOM Subtree</li>
<li defer>比較目前的Virtual DOM Subtree</li>
<li defer>記錄下要更新的數據差異</li>
<li defer>進行批量更新(Batched Update)</li>
</ul>

<!--
Explains how Virtual DOM works.
-->

===

<h2>高效的Rendering</h2>

<ul>
<li defer>高效的JavaScript</li>
<li defer>批量處理DOM API的讀寫操作</li>
<li defer>更新速度可達到60fps</li>
</ul>

<!--
List of benefits of using vurtual DOM.
-->

===

<h2>Virtual DOM</h2>

<p>可在任何執行JavaScript的環境下運作</p>

<div class="bricks">
  <em defer>Node JS</em>
  <em defer>PHP - V8js</em>
</div>
<div class="bricks">
  <em defer>Python - PyReact</em>
  <em defer>Web Worker</em>
</div>

<!--
List of languages that can use vurtual DOM for rendering.
-->

===

<h2>React的基本分層架構</h2>

<ul class="blocks">
  <li defer>Data Input Interface</li>
  <li defer>Components Composition</li>
  <li defer>Rendering</li>
</ul>

<!--
List of the basic layered architecture of React rendering.
-->

===

<h2>Events</h2>
<xmp>
// <Hello name="Hedger" />

var Hello = React.createClass({
  render: function() {
    return <button onClick={this._sayHi}>click</button>;
  },

  _sayHi: function(event) {
    event.preventDefault();
    alert('Hello, ' + this.props.name);
  }
});
</xmp>

<!--
Explains how Events works in React:
1. It uses event delegation for performance.
2. It supports auto-binding.
3. It uses the AbstractEvent which is environment agonistic.
-->

===

<h2>參考資源</h2>

<ul>
  <li>
    <a href="http://facebook.github.io/react">React JS</a>
  </li>
  <li>
    <a href="http://facebook.github.io/react/support.html">
    Community Support
    </a>
  </li>
</ul>

<!--
List of external resources.
-->

===

<h2>DEMO</h2>

<ul>
<li>React JS Fiddler</li>  
<li>Todo List</li>
<li>Simple Clock</li>
<li>Wolfenstein3D-react </li>
<li>React VS Angular</li>
</ul> 
<!--
List of examples and DEMOs.
-->








