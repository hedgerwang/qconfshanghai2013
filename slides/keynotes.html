<h1>跨终端的Web設計模式/h1>

===

<h2>關於</h2>
<ul>
  <li defer>Hedger Wang</li>
  <li defer>前端工程師</li>
  <li defer>2011 - Facebook</li>
  <li defer>2008 - Google</li>
  <li defer>2004 - Yahoo</li>
</ul>

===

<h2>更多終端</h2>

===

<a class="image"
   href="http://opensignal.com/reports/fragmentation-2013">
  <img src="images/adnroid_device_fragmentation.png" border="0" />
</a>
<small>Android Fragmentation Visualized (July 2013)</small>

===

<h2>更多差異</h2>

===

<p>
  <img src="images/wurfl.png" border="0" />
  <a href="http://www.tera-wurfl.com/explore/search.php?action=browse">
    WURFL
  </a>
</p>

===

<h2>從Web到原生應用</h2>

===

<h2>Web應用</h2>
<h3 defer>寬度</h3>

<!--
- Feature Parity
- Experimental Features
- e.g. Google Map, Google+, Facebook
-->

===

<h2>原生應用</h2>
<h3 defer>深度</h3>

<!--
  瀏覽器的編程模型還是90年代流行的單進程單線程 (single process single thread)，
  但原生實現(比如用Object C)的APP可以用多線程。 這一點帶來的作用是致命的。 移動端編寫APP，
  可以使用多個線程， 第一個線程， 被稱作主線程(main thread)， 編程的第一原則是don't do
  heavy work on main thread。 通常只讓它處理UI事件等， 其他重度的工作讓其他背景線程來做。
  但瀏覽器只有一個線程， 所有的事情都是它干。移動瀏覽器編程一上來就破了第一原則。 在台式機上，
  瀏覽器編程還沒有太多問題， 因為夠快(此外， 桌面瀏覽器對於Web Worker的支持也比較完善);
  但在移動端， 這個弊端很明顯。 我來舉個例子， 比如你在用瀏覽器看朋友的照片，
  你發的評論被發到服務器端， 此時你接著用手指往下拉屏; 此時， 服務器端返回信息， 評論發佈成功，
  瀏覽器中唯一的線程可能停止處理屏幕滾動(scrolling)而來處理服務器的返回信息，
  由於移動設備的處理器(尤其單進程瀏覽器只能用上單核， 即使是多核手機!)和內存(處於省電原因使用
  低耗電的DDR1， 這一點和現在PC使用的DDR3相差甚遠)的不給力， 完全可能造成滾動處理的不連續。
  通常手機的刷新率是60MHZ， 即每一幀不超過15ms; 如果處理的延時大大超過15ms，
  那麼就會出現跳幀， 肉眼就能看出來。 這是交互操作(比如拉動， 滾動等)很多的APP，
  如果是由HTML5實現， 出現拉動的時候停在那裡一個很重要的原因。 所以， 如果你的APP是相對靜態的，
  不需要很多對於照片， 多點觸摸， 多向拉動的處理， 那完全可以用HTML5來實現; 如果不是，
  比如信息流的展示， 遊戲等等， 還是乖乖的用原生的去實現。
-->

===

<blockquote>
  &ldquo;
  最大的錯誤就是在HTML5上下注太多
  &rdquo;
</blockquote>
<small>馬克‧扎克伯格, 9/11/2012</small>

===

<blockquote cite="http://venturebeat.com/2013/04/17/linkedin-mobile-web-breakup">
  &ldquo;
  毋庸置疑地，我們將會從HTML5轉向原生應用
  &rdquo;
</blockquote>
<small>LinkedIn</small>

===

<blockquote cite="https://blog.twitter.com/2012/improving-performance-twittercom">
  &ldquo;
  將頁面呈現的工作從客戶端移回到服務器端後，客戶端感受到的效能將會顯著地改善
  &rdquo;
</blockquote>
<small>Twitter</small>

===

<h2>反思</h2>

===

<h2>Web應用 用戶端</h3>
<ul>
  <li defer>工具</li>
  <li defer>相容性</li>
  <li defer>效能</li>
</ul>

===

<h2>
前端 &gt;= 用戶端
</h2>


===

<h2>工具 : JavaScipt</h2>

===

<h2>去框架化</h2>

===

<h2>過去</h2>

<xmp defer>

// google closure
goog.require('goog.dom.classes');
goog.dom.classes.add(element, 'goog');

</xmp>


<xmp defer>

// yui
YAHOO.util.Dom.addClass(element, 'yui');

</xmp>

<xmp defer>

// jQuery
$(element).addClass('jQuery');

</xmp>

<xmp defer>

// dojo
dojo.addClass(element), 'dojo');

</xmp>

===

<h2>現在</h2>

<xmp>
// ES6, CommonJS
var addClass = require('addClass');
addClass(element, 'red');
</xmp>

===

<h2>標準化</h2>

===

<h2>過去</h2>

<xmp defer>
// google closure
goog.inherits(ChildClass, ParentClass);
</xmp>

<xmp defer>
// yui
Y.extend(ChildClass, ParentClass)
</xmp>

<xmp  defer>
// jQuery
$.extend(ChildClass.prototype, new ParentClass)
</xmp>

<xmp defer>
// dojo
dojo.declare("ChildClass", ParentClass);
</xmp>

===

<h2>現在</h2>

<xmp>
class ChildClass extends ParentClass {

}
</xmp>

===

<h2>未來（進行中）</h2>

<xmp defer>
  var a1 = ['apple', 'banana', 'carrot'];
</xmp>
<xmp defer>
  var a2 = a.map(function(s){ return s.length });
</xmp>
<xmp defer>
  var a3 = a.map( s => s.length );
</xmp>

===

<h2>填充碼(Polyfill)</h2>
<!--
polyfill 模擬標準 API，所以能夠以一種面向所有瀏覽器未來的方式針對這些 API 進行開發，最終目標是：一旦對這些 API 的支持變成絕對大多數，則可以方便地去掉 polyfill，無需做任何額外工作。
-->
===

<h2>過去</h2>
<xmp defer>
// google closure
goog.now();
</xmp>

<xmp defer>
// jQuery
$.now();
</xmp>

<xmp defer>
// YUI
Y.now()
</xmp>

===

<h2>現在</h2>
<xmp>
Date.now()
</xmp>

===

<h2>ECMAScript5</h2>
<xmp defer>Array.isArray;</xmp>
<xmp defer>Array.prototype.map;</xmp>
<xmp defer>String.prototype.trim</xmp>
<xmp defer>Function.prototype.bind</xmp>
<xmp defer>JSON.parse</xmp>
<a defer href="https://developer.mozilla.org/en-US/docs/tag/ECMAScript5">
  ...
</a>

===

<h2>例外</h2>

<div class="bricks">
  <a href="https://www.dartlang.org/">Dart</a>
  <a href="http://coffeescript.org/">CoffeeScript</a>
  <a href="http://www.typescriptlang.org/">TypeScript</a>
</div>

===

<h2>重述要點</h2>
<ul>
  <li>模塊化</li>
  <li>標準化</li>
  <li defer>開源化</li>
</ul>

===

<h2>相容性 : UI</h2>

<ul>
  <li defer>Web</li>
  <li defer>HTML + CSS + JS</li>
  <li defer>Data + View + Controller</li>
</p>

===

<h2>過去</h2>

<xmp>
<div
  class="goog-custom-button goog-inline-block"
  role="button"
  tabindex="0">
  <div class="goog-inline-block goog-custom-button-outer-box">
    <div class="goog-inline-block goog-custom-button-inner-box">
      My Button
    </div>
  </div>
</div>
</xmp>

<a href="http://closure-library.googlecode.com/git/closure/goog/demos/button.html">
  goog.ui.CustomButton
</a>

===

<h2>現在</h2>

<xmp>
<CustomButton label="My Button" />
</xmp>

===

<h2>封装化</h2>

<xmp>
<UserLoginForm redirectURI={$redirectURI}/>
</xmp>

<ul defer>
  <li>
    <a href="http://www.chromium.org/blink/web-components">
      Web Components
    </a>
  </li>
</ul>

===

<h2>組合化</h2>

<xmp>
// <UserLoginForm />

<fieldset>
  <input type="hidden" value={$redirectURI} />
  <input type="text" name="id" />
  <input type="password" name="pwd" />
  <CustomButton label="登入" type="submit" />
</fieldset>
</xmp>

<p defer>優先使用（對象）組合，而非（類）繼承</p>

===

<h2>實例</h2>

<div class="bricks">
  <a href="http://www.w3.org/TR/2013/WD-components-intro-20130606/">
    Web Components
  </a>
  <br />
  <a href="https://www.dartlang.org/articles/web-ui/#components">
    Dart Web Components
  </a>
  <a href="http://docs.angularjs.org/guide/directive">
    Angular Directive
  </a>
  <br />
  <a href="http://www.polymer-project.org/">
    Polymer
  </a>
  <a href="https://hacks.mozilla.org/2013/08/introducing-brick-minimal-markup-web-components-for-faster-app-development/">
    Brick
  </a>
  <br />
  <a href="https://github.com/facebook/xhp">
    XHP
  </a>
  <a href="http://facebook.github.io/react/">
    React
  </a>
</div>

===

<h2>自適應化</h2>

===

<xmp>
<img src="icon.png" />
</xmp>

<xmp defer>
// HiRes Display
<img src="http://f.com/icon.2x.png" alt="icon" />
</xmp>

<xmp defer>
// WebView in Native
<img src="file://fcom/icon.2x.png" alt="icon" />
</xmp>

<xmp defer>
// Sprited Image
<i class="sprited_icon_ico">icon</em>
</xmp>

<xmp defer>
// Low speed connection
<a href="http://f.com/icon.png">icon</a>
</xmp>

===

<xmp>
// HTML5
<span>
  <input placeholder="type something" type="text"/>
</span>
</xmp>

<xmp defer>
// HTML4-
<span>
  <span class="placeholder">type something</span>
  <input type="text" />
</span>
</xmp>

===

<h2>聲明化</h2>
<p>Declarative</p>

===

<h2>過去</h2>

<xmp>
var form = new Form();
var textField = new TextField();
var submitButton = new SubmitButton("submit");
form.appendChild(textField);
form.appendChild(submitButton);
submitButton.onClick = onSubmitClick;
</xmp>

===

<h2>現在</h2>
<xmp>
<Form>
  <TextField />
  <SubmitButton label="submit" onClick="onSubmitClick" />
</Form>
</xmp>

===

<h2>併行化</h2>

===

<h2>過去</h2>

<div class="bricks">
  <em defer>Component 1</em><br />
  <em defer>Component 2</em><br />
  <em defer>Component 3</em><br />
  <em defer>Component 4</em>
</div>

===

<h2>現在</h2>
<div class="bricks">
  <em>Component 1</em>
  <em>Component 2</em>
  <em>Component 3</em>
  <em>Component 4</em>
</div>

===

<h2>實例</h2>
<div class="bricks">
  <em>Webkit Threaded Compositing</em>
  <em>PHP Generators</em>
</div>

===

<h2>重述要點</h2>
<ul>
  <li>封裝化</li>
  <li>組合化</li>
  <li>自適應化</li>
  <li>聲明化</li>
  <li>併行化</li>
</ul>

===

<h2>效能 </h2>

===

<p>Web Server</p>
<p>+</p>
<p>Web Client</p>

===

<p>Native View</p>
<p>+</p>
<p>Web View</p>

===

<h2>制度與文化</h2>

<img src="images/fb_posters.png" />


===

<h2>謝謝</h2>



